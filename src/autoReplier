// ============================================
// Auto Replier Module
// Handles automatic replies to messages
// Version: 1.0.0
// ============================================

const fs = require('fs').promises;
const path = require('path');

class AutoReplier {
    constructor() {
        this.isEnabled = true;
        this.replies = new Map();
        this.keywordPatterns = new Map();
        this.contextualReplies = new Map();
        this.replyStats = new Map();
        this.cooldowns = new Map();
        
        this.config = {
            enabledByDefault: true,
            maxRepliesPerUser: 10,
            cooldownPeriod: 30000, // 30 seconds
            replyDelay: 1000, // 1 second
            learnFromReplies: true,
            smartMatching: true,
            replyToGroups: true,
            replyToPrivate: true,
            ignoreBots: true,
            maxKeywords: 1000,
            responseTemplates: {
                greeting: ['ŸÖÿ±ÿ≠ÿ®ÿßŸã!', 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸã!', 'ŸÖÿ±ÿ≠ÿ®ÿßŸã ÿ®ŸÉ!'],
                thanks: ['ÿπŸÅŸàÿßŸã!', 'ÿßŸÑÿπŸÅŸà!', 'ŸÑÿß ÿ¥ŸÉÿ± ÿπŸÑŸâ Ÿàÿßÿ¨ÿ®!'],
                help: ['ŸÉŸäŸÅ ŸäŸÖŸÉŸÜŸÜŸä ŸÖÿ≥ÿßÿπÿØÿ™ŸÉÿü', 'ŸÖÿßÿ∞ÿß ÿ™ÿ≠ÿ™ÿßÿ¨ÿü', 'ÿ£ŸÜÿß ŸáŸÜÿß ŸÑŸÖÿ≥ÿßÿπÿØÿ™ŸÉ'],
                unknown: ['ŸÑŸÖ ÿ£ŸÅŸáŸÖÿå ŸáŸÑ ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ™Ÿàÿ∂Ÿäÿ≠ÿü', 'ÿ¢ÿ≥ŸÅ ŸÑŸÖ ÿ£ŸÅŸáŸÖ ÿ≥ÿ§ÿßŸÑŸÉ', 'ŸäŸÖŸÉŸÜŸÉ ÿ•ÿπÿßÿØÿ© ÿµŸäÿßÿ∫ÿ© ÿ≥ÿ§ÿßŸÑŸÉÿü']
            }
        };
        
        this.dataFile = './data/autoReplies.json';
        this.statsFile = './data/replyStats.json';
        this.learningFile = './data/learnedReplies.json';
        
        // Initialize
        this.init();
        
        console.log('‚úÖ Auto Replier Initialized');
        console.log(`üìù Smart matching: ${this.config.smartMatching ? '‚úÖ Enabled' : '‚ùå Disabled'}`);
    }
    
    /**
     * Initialize auto replier
     */
    async init() {
        try {
            // Create directories
            await fs.mkdir(path.dirname(this.dataFile), { recursive: true });
            
            // Load existing data
            await this.loadReplies();
            await this.loadStats();
            await this.loadLearnedReplies();
            
            // Load default replies
            this.loadDefaultReplies();
            
            console.log(`üìä Loaded ${this.replies.size} auto-reply rules`);
            console.log(`üìà Smart patterns: ${this.keywordPatterns.size}`);
            
        } catch (error) {
            console.log('üìù Starting with default auto-reply configuration');
            this.loadDefaultReplies();
        }
    }
    
    /**
     * Load default replies
     */
    loadDefaultReplies() {
        const defaultReplies = [
            {
                keyword: 'ŸÖÿ±ÿ≠ÿ®ÿß',
                response: 'ŸÖÿ±ÿ≠ÿ®ÿßŸã! ŸÉŸäŸÅ ŸäŸÖŸÉŸÜŸÜŸä ŸÖÿ≥ÿßÿπÿØÿ™ŸÉÿü',
                exactMatch: false,
                priority: 10
            },
            {
                keyword: 'ÿßŸáŸÑÿß',
                response: 'ÿ£ŸáŸÑÿßŸã Ÿàÿ≥ŸáŸÑÿßŸã! ÿ£ŸÜÿß ÿ®Ÿàÿ™ WhatsApp ÿßŸÑŸÖÿµÿßÿ≠ÿ®',
                exactMatch: false,
                priority: 10
            },
            {
                keyword: 'ÿ¥ŸÉÿ±ÿß',
                response: 'ÿπŸÅŸàÿßŸã! ŸÑÿß ÿ¥ŸÉÿ± ÿπŸÑŸâ Ÿàÿßÿ¨ÿ®',
                exactMatch: false,
                priority: 9
            },
            {
                keyword: 'ŸÖÿ≥ÿßÿπÿØÿ©',
                response: 'ÿ£ÿ±ÿ≥ŸÑ !ŸÖÿ≥ÿßÿπÿØÿ© ŸÑÿ±ÿ§Ÿäÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ŸàÿßŸÖÿ± ÿßŸÑŸÖÿ™ÿßÿ≠ÿ©',
                exactMatch: false,
                priority: 8
            },
            {
                keyword: 'ÿßŸÑÿßŸàÿßŸÖÿ±',
                response: 'ÿßŸÑÿ£ŸàÿßŸÖÿ± ÿ™ÿ®ÿØÿ£ ÿ®ŸÄ ! ÿ£ÿ±ÿ≥ŸÑ !ŸÖÿ≥ÿßÿπÿØÿ© ŸÑŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÉÿßŸÖŸÑÿ©',
                exactMatch: false,
                priority: 8
            },
            {
                keyword: 'ÿßŸÑÿ≥ÿßÿπÿ©',
                response: `ÿßŸÑÿ≥ÿßÿπÿ© ÿßŸÑÿ¢ŸÜ: ${new Date().toLocaleTimeString()}`,
                exactMatch: false,
                priority: 5
            },
            {
                keyword: 'ÿßŸÑÿ™ÿßÿ±ŸäÿÆ',
                response: `ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸäŸàŸÖ: ${new Date().toLocaleDateString('ar-SA')}`,
                exactMatch: false,
                priority: 5
            },
            {
                keyword: 'ŸÖŸÜ ÿßŸÜÿ™',
                response: 'ÿ£ŸÜÿß ÿ®Ÿàÿ™ WhatsApp ÿßŸÑŸÖÿµÿßÿ≠ÿ®ÿå ÿ£ÿ≥ÿßÿπÿØ ŸÅŸä ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ® Ÿàÿ¨ŸÖÿπ ÿßŸÑÿ±Ÿàÿßÿ®ÿ∑ ŸàÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä',
                exactMatch: false,
                priority: 7
            }
        ];
        
        defaultReplies.forEach(reply => this.addReply(reply.keyword, reply.response, reply));
    }
    
    /**
     * Handle incoming message for auto-reply
     * @param {Object} message - WhatsApp message
     * @param {Object} sock - WhatsApp socket
     */
    async handleMessage(message, sock) {
        if (!this.isEnabled) return;
        
        try {
            // Skip if message is from bot itself
            if (message.key.fromMe) return;
            
            // Check if should ignore (bot, etc.)
            if (this.shouldIgnore(message)) return;
            
            // Check cooldown
            if (this.isOnCooldown(message.key.remoteJid)) return;
            
            // Extract text
            const text = this.extractMessageText(message);
            if (!text || text.trim().length === 0) return;
            
            // Check if starts with command (ignore auto-reply for commands)
            if (text.startsWith('!')) return;
            
            // Find matching reply
            const reply = this.findMatchingReply(text, message);
            
            if (reply) {
                // Add cooldown
                this.addCooldown(message.key.remoteJid);
                
                // Add delay before reply
                await this.delay(this.config.replyDelay);
                
                // Send reply
                await this.sendReply(message, reply, sock);
                
                // Update statistics
                this.updateStats(message.key.remoteJid, reply.keyword);
                
                // Learn from interaction if enabled
                if (this.config.learnFromReplies) {
                    await this.learnFromInteraction(text, reply);
                }
                
                console.log(`ü§ñ Auto-reply sent for keyword: ${reply.keyword}`);
            }
            
        } catch (error) {
            console.error('‚ùå Error in auto-reply handler:', error);
        }
    }
    
    /**
     * Find matching reply for text
     */
    findMatchingReply(text, message) {
        const normalizedText = this.normalizeText(text);
        
        // Check exact matches first
        for (const [keyword, replyData] of this.replies.entries()) {
            if (replyData.exactMatch) {
                if (normalizedText === this.normalizeText(keyword)) {
                    return replyData;
                }
            } else {
                // Check if keyword appears in text
                if (normalizedText.includes(this.normalizeText(keyword))) {
                    return replyData;
                }
            }
        }
        
        // Check smart patterns if enabled
        if (this.config.smartMatching) {
            const smartReply = this.findSmartReply(normalizedText);
            if (smartReply) return smartReply;
        }
        
        // Check contextual replies
        const contextualReply = this.findContextualReply(message);
        if (contextualReply) return contextualReply;
        
        return null;
    }
    
    /**
     * Find smart reply using pattern matching
     */
    findSmartReply(text) {
        for (const [pattern, replyData] of this.keywordPatterns.entries()) {
            try {
                const regex = new RegExp(pattern, 'i');
                if (regex.test(text)) {
                    return replyData;
                }
            } catch (error) {
                // Invalid regex pattern, skip
                console.warn(`‚ö†Ô∏è Invalid regex pattern: ${pattern}`);
            }
        }
        return null;
    }
    
    /**
     * Find contextual reply based on message context
     */
    findContextualReply(message) {
        const jid = message.key.remoteJid;
        
        // Check if this is a follow-up to previous interaction
        const lastInteraction = this.contextualReplies.get(jid);
        if (lastInteraction && Date.now() - lastInteraction.timestamp < 300000) { // 5 minutes
            const followUpReply = this.replies.get(lastInteraction.keyword + '_followup');
            if (followUpReply) {
                return followUpReply;
            }
        }
        
        return null;
    }
    
    /**
     * Send reply to message
     */
    async sendReply(message, replyData, sock) {
        const jid = message.key.remoteJid;
        
        try {
            // Format response
            let response = this.formatResponse(replyData.response, message);
            
            // Add random variation from templates if available
            if (replyData.template && this.config.responseTemplates[replyData.template]) {
                const templates = this.config.responseTemplates[replyData.template];
                const randomTemplate = templates[Math.floor(Math.random() * templates.length)];
                response = randomTemplate;
            }
            
            // Send reply
            await sock.sendMessage(jid, { text: response });
            
            // Store contextual information
            this.contextualReplies.set(jid, {
                keyword: replyData.keyword,
                timestamp: Date.now(),
                messageId: message.key.id
            });
            
        } catch (error) {
            console.error('‚ùå Failed to send auto-reply:', error);
        }
    }
    
    /**
     * Format response with message context
     */
    formatResponse(response, message) {
        let formatted = response;
        
        // Replace variables
        const senderName = message.pushName || 'ÿµÿØŸäŸÇŸä';
        const time = new Date().toLocaleTimeString('ar-SA');
        const date = new Date().toLocaleDateString('ar-SA');
        
        formatted = formatted.replace(/{name}/g, senderName);
        formatted = formatted.replace(/{time}/g, time);
        formatted = formatted.replace(/{date}/g, date);
        formatted = formatted.replace(/{user}/g, senderName);
        
        // Add emoji based on time of day
        if (formatted.includes('{emoji}')) {
            const hour = new Date().getHours();
            let emoji = 'ü§ñ';
            
            if (hour >= 5 && hour < 12) emoji = 'üåû';
            else if (hour >= 12 && hour < 17) emoji = '‚òÄÔ∏è';
            else if (hour >= 17 && hour < 21) emoji = 'üåÜ';
            else emoji = 'üåô';
            
            formatted = formatted.replace(/{emoji}/g, emoji);
        }
        
        return formatted;
    }
    
    /**
     * Add new auto-reply rule
     */
    addReply(keyword, response, options = {}) {
        if (this.replies.size >= this.config.maxKeywords) {
            console.warn('‚ö†Ô∏è Maximum number of keywords reached');
            return false;
        }
        
        const normalizedKeyword = keyword.toLowerCase().trim();
        
        const replyData = {
            keyword: normalizedKeyword,
            response: response,
            exactMatch: options.exactMatch || false,
            priority: options.priority || 5,
            template: options.template,
            createdAt: new Date().toISOString(),
            usageCount: 0,
            lastUsed: null
        };
        
        // Store in replies map
        this.replies.set(normalizedKeyword, replyData);
        
        // Create smart pattern if needed
        if (options.pattern) {
            this.keywordPatterns.set(options.pattern, replyData);
        }
        
        // Auto-save
        this.saveReplies();
        
        console.log(`üìù Added auto-reply for: "${keyword}"`);
        return true;
    }
    
    /**
     * Remove auto-reply rule
     */
    removeReply(keyword) {
        const normalizedKeyword = keyword.toLowerCase().trim();
        
        if (this.replies.delete(normalizedKeyword)) {
            // Also remove from patterns
            for (const [pattern, data] of this.keywordPatterns.entries()) {
                if (data.keyword === normalizedKeyword) {
                    this.keywordPatterns.delete(pattern);
                }
            }
            
            this.saveReplies();
            console.log(`üóëÔ∏è Removed auto-reply for: "${keyword}"`);
            return true;
        }
        
        return false;
    }
    
    /**
     * Update existing reply
     */
    updateReply(keyword, newResponse, options = {}) {
        const normalizedKeyword = keyword.toLowerCase().trim();
        
        if (this.replies.has(normalizedKeyword)) {
            const existing = this.replies.get(normalizedKeyword);
            
            const updated = {
                ...existing,
                response: newResponse || existing.response,
                exactMatch: options.exactMatch !== undefined ? options.exactMatch : existing.exactMatch,
                priority: options.priority || existing.priority,
                template: options.template || existing.template,
                updatedAt: new Date().toISOString()
            };
            
            this.replies.set(normalizedKeyword, updated);
            this.saveReplies();
            
            console.log(`‚úèÔ∏è Updated auto-reply for: "${keyword}"`);
            return true;
        }
        
        return false;
    }
    
    /**
     * Get all replies
     */
    getReplies() {
        return Array.from(this.replies.values()).sort((a, b) => b.priority - a.priority);
    }
    
    /**
     * Get reply by keyword
     */
    getReply(keyword) {
        return this.replies.get(keyword.toLowerCase().trim());
    }
    
    /**
     * Search replies by keyword
     */
    searchReplies(searchTerm) {
        const term = searchTerm.toLowerCase();
        return Array.from(this.replies.values())
            .filter(reply => 
                reply.keyword.includes(term) || 
                reply.response.toLowerCase().includes(term)
            )
            .sort((a, b) => b.priority - a.priority);
    }
    
    /**
     * Enable/disable auto-replier
     */
    setEnabled(enabled) {
        this.isEnabled = enabled;
        console.log(`‚öôÔ∏è Auto-replier ${enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}`);
        return enabled;
    }
    
    /**
     * Toggle auto-replier
     */
    toggle() {
        this.isEnabled = !this.isEnabled;
        console.log(`‚öôÔ∏è Auto-replier ${this.isEnabled ? '‚úÖ Enabled' : '‚ùå Disabled'}`);
        return this.isEnabled;
    }
    
    /**
     * Update configuration
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        console.log('‚öôÔ∏è Auto-replier configuration updated');
        return { success: true, config: this.config };
    }
    
    /**
     * Learn from interaction
     */
    async learnFromInteraction(userMessage, replyUsed) {
        try {
            // Store interaction for learning
            const learned = {
                userMessage: userMessage,
                replyKeyword: replyUsed.keyword,
                replyResponse: replyUsed.response,
                timestamp: new Date().toISOString(),
                success: true // Assume success for now
            };
            
            // Load existing learned data
            let learnedData = [];
            try {
                const data = await fs.readFile(this.learningFile, 'utf8');
                learnedData = JSON.parse(data);
            } catch (error) {
                learnedData = [];
            }
            
            // Add new learning
            learnedData.push(learned);
            
            // Keep only last 1000 interactions
            if (learnedData.length > 1000) {
                learnedData = learnedData.slice(-1000);
            }
            
            // Save back
            await fs.writeFile(this.learningFile, JSON.stringify(learnedData, null, 2), 'utf8');
            
            // Analyze for patterns (simple implementation)
            this.analyzePatterns(learnedData);
            
        } catch (error) {
            console.error('‚ùå Error learning from interaction:', error);
        }
    }
    
    /**
     * Analyze patterns from learned data
     */
    analyzePatterns(learnedData) {
        // Simple pattern analysis - group similar messages
        const recentData = learnedData.slice(-100); // Last 100 interactions
        
        const keywordGroups = {};
        
        recentData.forEach(interaction => {
            const keyword = interaction.replyKeyword;
            if (!keywordGroups[keyword]) {
                keywordGroups[keyword] = [];
            }
            keywordGroups[keyword].push(interaction.userMessage);
        });
        
        // For each keyword, find common patterns in user messages
        for (const [keyword, messages] of Object.entries(keywordGroups)) {
            if (messages.length >= 3) { // Need at least 3 examples
                const commonWords = this.findCommonWords(messages);
                if (commonWords.length > 0) {
                    // Create pattern from common words
                    const pattern = commonWords.map(word => `\\b${word}\\b`).join('.*');
                    
                    // Add as smart pattern if not exists
                    if (!this.keywordPatterns.has(pattern)) {
                        const replyData = this.replies.get(keyword);
                        if (replyData) {
                            this.keywordPatterns.set(pattern, replyData);
                            console.log(`üß† Learned pattern for "${keyword}": ${pattern}`);
                        }
                    }
                }
            }
        }
    }
    
    /**
     * Find common words in messages
     */
    findCommonWords(messages) {
        const wordFrequency = {};
        const normalizedMessages = messages.map(msg => this.normalizeText(msg));
        
        normalizedMessages.forEach(message => {
            const words = message.split(/\s+/).filter(word => word.length > 2);
            const uniqueWords = [...new Set(words)];
            
            uniqueWords.forEach(word => {
                wordFrequency[word] = (wordFrequency[word] || 0) + 1;
            });
        });
        
        // Find words that appear in at least 50% of messages
        const threshold = messages.length * 0.5;
        return Object.entries(wordFrequency)
            .filter(([word, count]) => count >= threshold)
            .map(([word]) => word)
            .slice(0, 5); // Top 5 common words
    }
    
    /**
     * Update usage statistics
     */
    updateStats(jid, keyword) {
        // Update keyword stats
        const replyData = this.replies.get(keyword);
        if (replyData) {
            replyData.usageCount = (replyData.usageCount || 0) + 1;
            replyData.lastUsed = new Date().toISOString();
        }
        
        // Update user stats
        const userStats = this.replyStats.get(jid) || { count: 0, lastReply: null, keywords: [] };
        userStats.count++;
        userStats.lastReply = new Date().toISOString();
        userStats.keywords.push(keyword);
        
        // Keep only last 20 keywords per user
        if (userStats.keywords.length > 20) {
            userStats.keywords = userStats.keywords.slice(-20);
        }
        
        this.replyStats.set(jid, userStats);
        
        // Save stats periodically
        if (userStats.count % 10 === 0) {
            this.saveStats();
        }
    }
    
    /**
     * Add cooldown for user
     */
    addCooldown(jid) {
        this.cooldowns.set(jid, Date.now());
        
        // Clean up old cooldowns
        setTimeout(() => {
            this.cooldowns.delete(jid);
        }, this.config.cooldownPeriod);
    }
    
    /**
     * Check if user is on cooldown
     */
    isOnCooldown(jid) {
        const lastReply = this.cooldowns.get(jid);
        if (!lastReply) return false;
        
        const timeSinceLastReply = Date.now() - lastReply;
        return timeSinceLastReply < this.config.cooldownPeriod;
    }
    
    /**
     * Check if should ignore message
     */
    shouldIgnore(message) {
        // Check if message is from bot
        if (this.config.ignoreBots && message.key.id?.includes('bot')) {
            return true;
        }
        
        // Check if private message and disabled
        const isPrivate = !message.key.remoteJid.includes('@g.us');
        if (isPrivate && !this.config.replyToPrivate) {
            return true;
        }
        
        // Check if group message and disabled
        const isGroup = message.key.remoteJid.includes('@g.us');
        if (isGroup && !this.config.replyToGroups) {
            return true;
        }
        
        // Check user reply limit
        const userStats = this.replyStats.get(message.key.remoteJid);
        if (userStats && userStats.count >= this.config.maxRepliesPerUser) {
            console.log(`‚ö†Ô∏è Reply limit reached for user: ${message.key.remoteJid}`);
            return true;
        }
        
        return false;
    }
    
    /**
     * Extract text from message
     */
    extractMessageText(message) {
        if (message.message?.conversation) {
            return message.message.conversation;
        }
        
        if (message.message?.extendedTextMessage?.text) {
            return message.message.extendedTextMessage.text;
        }
        
        if (message.message?.imageMessage?.caption) {
            return message.message.imageMessage.caption;
        }
        
        if (message.message?.videoMessage?.caption) {
            return message.message.videoMessage.caption;
        }
        
        if (message.message?.documentMessage?.caption) {
            return message.message.documentMessage.caption;
        }
        
        return '';
    }
    
    /**
     * Normalize text for comparison
     */
    normalizeText(text) {
        if (!text) return '';
        
        return text
            .toLowerCase()
            .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // Remove diacritics
            .replace(/[^\w\s\u0600-\u06FF]/g, '') // Keep Arabic and alphanumeric
            .replace(/\s+/g, ' ')
            .trim();
    }
    
    /**
     * Save replies to file
     */
    async saveReplies() {
        try {
            const data = {
                replies: Array.from(this.replies.values()),
                patterns: Array.from(this.keywordPatterns.entries()).map(([pattern, data]) => ({
                    pattern,
                    keyword: data.keyword
                })),
                savedAt: new Date().toISOString(),
                version: '1.0.0'
            };
            
            await fs.writeFile(this.dataFile, JSON.stringify(data, null, 2), 'utf8');
            
        } catch (error) {
            console.error('‚ùå Failed to save replies:', error);
        }
    }
    
    /**
     * Load replies from file
     */
    async loadReplies() {
        try {
            const data = await fs.readFile(this.dataFile, 'utf8');
            const parsed = JSON.parse(data);
            
            // Load replies
            this.replies.clear();
            if (parsed.replies) {
                parsed.replies.forEach(reply => {
                    this.replies.set(reply.keyword, reply);
                });
            }
            
            // Load patterns
            this.keywordPatterns.clear();
            if (parsed.patterns) {
                parsed.patterns.forEach(({ pattern, keyword }) => {
                    const replyData = this.replies.get(keyword);
                    if (replyData) {
                        this.keywordPatterns.set(pattern, replyData);
                    }
                });
            }
            
        } catch (error) {
            console.log('üìù No existing reply data found');
        }
    }
    
    /**
     * Save statistics to file
     */
    async saveStats() {
        try {
            const statsData = {
                userStats: Array.from(this.replyStats.entries()).map(([jid, stats]) => ({
                    jid,
                    ...stats
                })),
                keywordStats: Array.from(this.replies.values()).map(reply => ({
                    keyword: reply.keyword,
                    usageCount: reply.usageCount || 0,
                    lastUsed: reply.lastUsed
                })),
                savedAt: new Date().toISOString()
            };
            
            await fs.writeFile(this.statsFile, JSON.stringify(statsData, null, 2), 'utf8');
            
        } catch (error) {
            console.error('‚ùå Failed to save stats:', error);
        }
    }
    
    /**
     * Load statistics from file
     */
    async loadStats() {
        try {
            const data = await fs.readFile(this.statsFile, 'utf8');
            const parsed = JSON.parse(data);
            
            // Load user stats
            if (parsed.userStats) {
                parsed.userStats.forEach(({ jid, ...stats }) => {
                    this.replyStats.set(jid, stats);
                });
            }
            
            // Load keyword stats
            if (parsed.keywordStats) {
                parsed.keywordStats.forEach(({ keyword, usageCount, lastUsed }) => {
                    const replyData = this.replies.get(keyword);
                    if (replyData) {
                        replyData.usageCount = usageCount;
                        replyData.lastUsed = lastUsed;
                    }
                });
            }
            
        } catch (error) {
            console.log('üìù No existing stats data found');
        }
    }
    
    /**
     * Load learned replies
     */
    async loadLearnedReplies() {
        try {
            const data = await fs.readFile(this.learningFile, 'utf8');
            const parsed = JSON.parse(data);
            
            // Analyze learned patterns
            this.analyzePatterns(parsed);
            
        } catch (error) {
            console.log('üìù No learned reply data found');
        }
    }
    
    /**
     * Get statistics
     */
    getStats() {
        const totalReplies = Array.from(this.replies.values())
            .reduce((sum, reply) => sum + (reply.usageCount || 0), 0);
        
        const topKeywords = Array.from(this.replies.values())
            .filter(reply => reply.usageCount > 0)
            .sort((a, b) => (b.usageCount || 0) - (a.usageCount || 0))
            .slice(0, 10);
        
        const topUsers = Array.from(this.replyStats.entries())
            .sort(([jidA, statsA], [jidB, statsB]) => statsB.count - statsA.count)
            .slice(0, 10);
        
        return {
            enabled: this.isEnabled,
            totalKeywords: this.replies.size,
            smartPatterns: this.keywordPatterns.size,
            totalRepliesSent: totalReplies,
            activeUsers: this.replyStats.size,
            topKeywords,
            topUsers: topUsers.map(([jid, stats]) => ({
                jid: jid.substring(0, 20) + '...',
                count: stats.count,
                lastReply: stats.lastReply
            })),
            config: {
                ...this.config,
                responseTemplates: Object.keys(this.config.responseTemplates)
            }
        };
    }
    
    /**
     * Reset statistics
     */
    resetStats() {
        this.replyStats.clear();
        
        // Reset usage counts in replies
        for (const reply of this.replies.values()) {
            reply.usageCount = 0;
            reply.lastUsed = null;
        }
        
        console.log('üßπ Auto-reply statistics reset');
        return true;
    }
    
    /**
     * Export replies to file
     */
    async exportReplies(format = 'json') {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            let filePath, content;
            
            if (format === 'json') {
                filePath = `./data/exports/replies_export_${timestamp}.json`;
                content = JSON.stringify(this.getReplies(), null, 2);
            } else if (format === 'txt') {
                filePath = `./data/exports/replies_export_${timestamp}.txt`;
                content = this.generateTextExport();
            } else {
                throw new Error(`Unsupported format: ${format}`);
            }
            
            await fs.mkdir(path.dirname(filePath), { recursive: true });
            await fs.writeFile(filePath, content, 'utf8');
            
            console.log(`üíæ Exported ${this.replies.size} replies to ${filePath}`);
            
            return {
                success: true,
                filePath,
                count: this.replies.size
            };
            
        } catch (error) {
            console.error('‚ùå Failed to export replies:', error);
            return { success: false, message: error.message };
        }
    }
    
    /**
     * Generate text export
     */
    generateTextExport() {
        let text = 'üìù Auto-Replies Export\n';
        text += '='.repeat(60) + '\n\n';
        text += `üìÖ Exported: ${new Date().toLocaleString()}\n`;
        text += `üìä Total Replies: ${this.replies.size}\n\n`;
        
        const replies = this.getReplies();
        
        replies.forEach((reply, index) => {
            text += `${index + 1}. ${reply.keyword}\n`;
            text += `   üìù Response: ${reply.response}\n`;
            text += `   ‚öôÔ∏è Exact Match: ${reply.exactMatch ? 'Yes' : 'No'}\n`;
            text += `   ‚≠ê Priority: ${reply.priority}\n`;
            text += `   üìà Used: ${reply.usageCount || 0} times\n`;
            if (reply.lastUsed) {
                text += `   üïí Last Used: ${new Date(reply.lastUsed).toLocaleString()}\n`;
            }
            text += '\n';
        });
        
        return text;
    }
    
    /**
     * Import replies from file
     */
    async importReplies(filePath) {
        try {
            const data = await fs.readFile(filePath, 'utf8');
            let importedReplies;
            
            if (filePath.endsWith('.json')) {
                importedReplies = JSON.parse(data);
            } else if (filePath.endsWith('.txt')) {
                importedReplies = this.parseTextImport(data);
            } else {
                throw new Error('Unsupported file format');
            }
            
            let importedCount = 0;
            let updatedCount = 0;
            
            importedReplies.forEach(reply => {
                if (reply.keyword && reply.response) {
                    if (this.replies.has(reply.keyword.toLowerCase())) {
                        this.updateReply(reply.keyword, reply.response, reply);
                        updatedCount++;
                    } else {
                        this.addReply(reply.keyword, reply.response, reply);
                        importedCount++;
                    }
                }
            });
            
            console.log(`üì• Imported ${importedCount} new replies, updated ${updatedCount} existing`);
            
            return {
                success: true,
                imported: importedCount,
                updated: updatedCount,
                total: this.replies.size
            };
            
        } catch (error) {
            console.error('‚ùå Failed to import replies:', error);
            return { success: false, message: error.message };
        }
    }
    
    /**
     * Parse text import
     */
    parseTextImport(text) {
        const replies = [];
        const lines = text.split('\n');
        let currentReply = null;
        
        lines.forEach(line => {
            line = line.trim();
            
            if (line.match(/^\d+\.\s+.+/)) {
                // New reply
                if (currentReply) {
                    replies.push(currentReply);
                }
                currentReply = {
                    keyword: line.replace(/^\d+\.\s+/, ''),
                    response: '',
                    exactMatch: false,
                    priority: 5
                };
            } else if (line.startsWith('Response:') && currentReply) {
                currentReply.response = line.replace('Response:', '').trim();
            } else if (line.startsWith('Exact Match:') && currentReply) {
                currentReply.exactMatch = line.includes('Yes');
            } else if (line.startsWith('Priority:') && currentReply) {
                currentReply.priority = parseInt(line.replace('Priority:', '').trim()) || 5;
            }
        });
        
        if (currentReply) {
            replies.push(currentReply);
        }
        
        return replies;
    }
    
    /**
     * Delay function
     */
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Export the class
module.exports = AutoReplier;

// Test the module if run directly
if (require.main === module) {
    console.log('üß™ Testing Auto Replier...\n');
    
    const autoReplier = new AutoReplier();
    
    // Test 1: Check status
    console.log('1. Getting status...');
    const status = autoReplier.getStats();
    console.log(`   Enabled: ${status.enabled}`);
    console.log(`   Keywords: ${status.totalKeywords}`);
    
    // Test 2: Add test reply
    console.log('\n2. Adding test reply...');
    autoReplier.addReply('ÿßÿÆÿ™ÿ®ÿßÿ±', 'Ÿáÿ∞ÿß ÿ±ÿØ ÿßÿÆÿ™ÿ®ÿßÿ±Ÿä!', { priority: 10 });
    console.log('   ‚úÖ Test reply added');
    
    // Test 3: Find matching reply
    console.log('\n3. Testing reply matching...');
    const testMessage = { 
        key: { 
            remoteJid: 'test@jid', 
            fromMe: false,
            id: 'test123'
        },
        pushName: 'Test User',
        message: { conversation: 'ŸÖÿ±ÿ≠ÿ®ÿß ŸÉŸäŸÅ ÿßŸÑÿ≠ÿßŸÑ' }
    };
    
    const reply = autoReplier.findMatchingReply('ŸÖÿ±ÿ≠ÿ®ÿß ŸÉŸäŸÅ ÿßŸÑÿ≠ÿßŸÑ', testMessage);
    console.log(`   Found reply: ${reply ? reply.keyword : 'None'}`);
    
    // Test 4: Get all replies
    console.log('\n4. Getting all replies...');
    const allReplies = autoReplier.getReplies();
    console.log(`   Total replies: ${allReplies.length}`);
    
    // Test 5: Export test
    console.log('\n5. Testing export...');
    setTimeout(async () => {
        const exportResult = await autoReplier.exportReplies('txt');
        console.log(`   Export: ${exportResult.success ? '‚úÖ Success' : '‚ùå Failed'}`);
        
        console.log('\nüß™ Test completed successfully');
    }, 1000);
}
